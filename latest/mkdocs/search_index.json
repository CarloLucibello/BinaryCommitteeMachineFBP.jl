{
    "docs": [
        {
            "location": "/", 
            "text": "BinaryCommitteeMachineFBP.jl documentation\n\n\nThis package implements the Focusing Belief Propagation algorithm for committee machines with binary weights described in the paper \nUnreasonable Effectiveness of Learning Neural Networks: From Accessible States and Robust Ensembles to Basic Algorithmic Schemes\n by Carlo Baldassi, Christian Borgs, Jennifer Chayes, Alessandro Ingrosso, Carlo Lucibello, Luca Saglietti and Riccardo Zecchina, Proc. Natl. Acad. Sci. U.S.A. (2016), \ndoi:10.1073/pnas.1608103113\n.\n\n\nThe package is tested against Julia \n0.4\n, \n0.5\n and \ncurrent\n \n0.6-dev\n on Linux, OS X, and Windows.\n\n\n\n\nInstallation\n\n\nTo install the module, use this command from within Julia:\n\n\njulia\n Pkg.clone(\nhttps://github.com/carlobaldassi/BinaryCommitteeMachineFBP.jl\n)\n\n\n\n\nDependencies will be installed automatically.\n\n\n\n\nUsage\n\n\nThe module is loaded as any other Julia module:\n\n\njulia\n using BinaryCommitteeMachineFBP\n\n\n\n\nThe code provides a main function, \nfocusingBP\n, and some auxiliary functions and types, documented below.\n\n\n#\n\n\nBinaryCommitteeMachineFBP.focusingBP\n \n \nFunction\n.\n\n\nfocusingBP(N, K, patternspec; keywords...)\n\n\n\n\nRun the Focusing Belief Propagation algorithm on a fully-connected committee machine with binary weights. \nN\n is the input (first layer) size, \nK\n the number of the hidden units (second layer size), and \npatternspec\n specifies how to build the patterns for the training set. Note that with the defult settings \nK\n must be odd (see notes for the \naccuracy1\n and \naccuracy2\n arguments below).\n\n\nPossible values of \npatternspec\n are:\n\n\n\n\na \nFloat64\n number: this is interpreted as the \n\u03b1\n parameter, and \nM = \u03b1*N*K\n random \u00b11 patterns are generated.\n\n\na \nTuple\n with \nVector{Vector{Float64}}\n and a \nVector{Float64}\n: these are the inputs and associated desired outputs.\n\n\na string: the patterns are read from a file (one input pattern per line, entries separated by whitespace, outputs are           assumed to be all 1); the file can be gzipped.\n\n\na \nPatterns\n object (which could be the output of a previous run of the function).\n\n\n\n\nNote\n: all inputs and outputs must be \u2208 {-1,1}.\n\n\nThe keyword arguments are:\n\n\n\n\nmax_iters\n (default = \n1000\n): maximum number of BP iterations per step. If convergence is not achieved in this many iterations,                                 the algorithm proceeds to the next step.\n\n\nmax_steps\n (default = \ntypemax(Int)\n): maximum number of focusing steps.\n\n\nseed\n (default = \n1\n): random seed.\n\n\ndamping\n (default = \n0\n): BP damping parameter (between \n0\n and \n1\n; \n0\n = no damping).\n\n\nquiet\n (default = \nfalse\n): whether to print on screen\n\n\naccuracy1\n (default = \n:accurate\n): accuracy of the messages computation at the hidden units level. Possible values are:                                      \n:accurate\n (Gaussian approximation, good for large \nN\n, works in \nO(N)\n time),                                      \n:exact\n (no approximation, uses convolutions, good for small \nN\n, works in \nO(N\u00b3)\n time, requires                                      \nN\n to be odd),                                      \n:none\n (a TAP-like approximation, fast but never very good, should probably be removed or done                                      properly...).\n\n\naccuracy2\n (default = \n:exact\n): accuracy of the messages computation at the output node level.                                   See \naccuracy1\n (and think of \nK\n instead of \nN\n).\n\n\nrandfact\n (default = \n0.01\n): random factor used in the initialization of the messages. Must be between \n0\n and \n1\n. Large values are                                not a good idea.\n\n\nfprotocol\n (default = \nStandardReinforcement(1e-2)\n): focusing protocol specification. See \nFocusingProtocol\n.\n\n\n\u03f5\n (default = \n1e-3\n): convergence criterion: BP is assumed to have converged when the difference between messages in two successive                         iterations is smaller than this value. Reduce it (e.g. to 1e-6) for more precise results, while increasing                         \nmax_iters\n.\n\n\nmessfmt\n (default = \n:tanh\n): internal storage format for messages: it can be either \n:tanh\n or \n:plain\n; \n:tanh\n is much more                                precise but slower.\n\n\ninitmess\n (default = \nnothing\n): how to initialize the messages. If \nnothing\n, they are initialized randomly; If a string is given,                                   they are read from a file (see also \nread_messages\n and \nwrite_messages\n). If a                                   \nMessages\n object is given (e.g. one returned from an earlier run of the function, or from                                   \nread_messages\n) it is used (and overwritten).\n\n\noutatzero\n (default = \ntrue\n): if \ntrue\n, the algorithm exits as soon as a solution to the learning problem is found, without waiting                                 for the focusing protocol to terminate.\n\n\nwriteoutfile\n (default = \n:auto\n): whether to write results on an output file. Can be \n:never\n, \n:always\n or \n:auto\n. The latter means                                     that a file is written when \noutatzero\n is set to \nfalse\n and only when BP converges. It can make sense                                     setting this to \n:always\n even when \noutfile\n is \nnothing\n to force the computation of the local                                     entropy and other thermodynamic quantities.\n\n\noutfile\n (default = \nnothing\n): the output file name. \nnothing\n means no output file is written. An empty string means using a default                                  file name of the form: \n\"results_BPCR_N$(N)_K$(K)_M$(M)_s$(seed).txt\"\n.\n\n\noutmessfiletmpl\n (default = \nnothing\n): template file name for writing the messages at each focusing step. The file name should include a                                          substring \n\"%gamma%\"\n which will be substituted with the value of the \n\u03b3\n parameter at each step.                                          If \nnothing\n, it is not used. If empty, the default will be used:                                          \n\"messages_BPCR_N$(N)_K$(K)_M$(M)_g%gamma%_s$(seed).txt.gz\"\n.                                          \nNote\n: this can produce a lot of fairly large files!.\n\n\n\n\nThe function returns three objects: the number of training errors, the messages and the patterns. The last two can be used as inputs to successive runs of the algorithms, as the \ninitmessages\n keyword argument and the \npatternspec\n argument, respectively.\n\n\nExample of a run which solves a problem with \nN * K = 1605\n synapses with \nK = 5\n at \n\u03b1 = 0.3\n:\n\n\njulia\n errs, messages, patterns = B.focusingBP(321, 5, 0.3, randfact=0.1, seed=135, max_iters=1, damping=0.5);\n\n\n\n\nsource\n\n\n\n\nFocusing protocols\n\n\n#\n\n\nBinaryCommitteeMachineFBP.FocusingProtocol\n \n \nType\n.\n\n\nFocusingProtocol\n\n\n\n\nAbstract type representing a protocol for the focusing procedure, i.e. a way to produce successive values for the quantities \n\u03b3\n, \ny\n and \n\u03b2\n. Currently, however, only \n\u03b2=Inf\n is supported. To be provided as an argument to \nfocusingBP\n.\n\n\nAvailable protocols are: \nStandardReinforcement\n, \nScoping\n, \nPseudoReinforcement\n and \nFreeScoping\n.\n\n\nsource\n\n\n#\n\n\nBinaryCommitteeMachineFBP.StandardReinforcement\n \n \nType\n.\n\n\nStandardReinforcement(r::Range) \n: FocusingProtocol\n\n\n\n\nStandard reinforcement protocol, returns \n\u03b3=Inf\n and \ny=1/(1-x)\n, where \nx\n is taken from the given range \nr\n.\n\n\nsource\n\n\nStandardReinforcement(dr::Float64) \n: FocusingProtocol\n\n\n\n\nShorthand for \nStandardReinforcement\n(0:dr:(1-dr))\n.\n\n\nsource\n\n\n#\n\n\nBinaryCommitteeMachineFBP.Scoping\n \n \nType\n.\n\n\nScoping(\u03b3r::Range, y) \n: FocusingProtocol\n\n\n\n\nFocusing protocol with fixed \ny\n and a varying \n\u03b3\n taken from the given \n\u03b3r\n range.\n\n\nsource\n\n\n#\n\n\nBinaryCommitteeMachineFBP.PseudoReinforcement\n \n \nType\n.\n\n\nPseudoReinforcement(r::Range...; x=0.5) \n: FocusingProtocol\n\n\n\n\nA focusing protocol in which both \n\u03b3\n and \ny\n are progressively increased, according to the formulas\n\n\n\u03b3 = atanh(\u03c1^x)\ny = 1+\u03c1^(1-2x)/(1-\u03c1)\n\n\n\n\nwhere \n\u03c1\n is taken from the given range(s) \nr\n. With \nx=0\n, this is basically the same as \nStandardReinforcement\n.\n\n\nsource\n\n\nPseudoReinforcement(dr::Float64; x=0.5) \n: FocusingProtocol\n\n\n\n\nShorthand for \nPseudoReinforcement\n(0:dr:(1-dr); x=x)\n.\n\n\nsource\n\n\n#\n\n\nBinaryCommitteeMachineFBP.FreeScoping\n \n \nType\n.\n\n\nFreeScoping(list::Vector{NTuple{2,Float64}}) \n: FocusingProtocol\n\n\n\n\nA focusing protocol which just returns the values of \n(\u03b3,y)\n from the given \nlist\n.\n\n\nExample:\n\n\nFreeScoping([(1/(1-x), (2-x)/(1-x)) for x = 0:0.01:0.99])\n\n\n\n\nsource\n\n\n\n\nReading and writing messages files\n\n\n#\n\n\nBinaryCommitteeMachineFBP.read_messages\n \n \nFunction\n.\n\n\nread_messages(filename, mag_type)\n\n\n\n\nReads messages from a file. \nmag_type\n is the internal storage format used in the resulting \nMessages\n object, it can be either \nMagT64\n (uses tanhs, accurate but slower) or \nMagP64\n (plain format, faster but inaccurate).\n\n\nThe file format is the one produced by \nwrite_messages\n.\n\n\nsource\n\n\n#\n\n\nBinaryCommitteeMachineFBP.write_messages\n \n \nFunction\n.\n\n\nwrite_messages(filename, messages)\n\n\n\n\nWrites messages to a file. The messages can be read back with \nread_messages\n. Note that the output is a plain text file compressed with gzip.\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#binarycommitteemachinefbpjl-documentation", 
            "text": "This package implements the Focusing Belief Propagation algorithm for committee machines with binary weights described in the paper  Unreasonable Effectiveness of Learning Neural Networks: From Accessible States and Robust Ensembles to Basic Algorithmic Schemes  by Carlo Baldassi, Christian Borgs, Jennifer Chayes, Alessandro Ingrosso, Carlo Lucibello, Luca Saglietti and Riccardo Zecchina, Proc. Natl. Acad. Sci. U.S.A. (2016),  doi:10.1073/pnas.1608103113 .  The package is tested against Julia  0.4 ,  0.5  and  current   0.6-dev  on Linux, OS X, and Windows.", 
            "title": "BinaryCommitteeMachineFBP.jl documentation"
        }, 
        {
            "location": "/#installation", 
            "text": "To install the module, use this command from within Julia:  julia  Pkg.clone( https://github.com/carlobaldassi/BinaryCommitteeMachineFBP.jl )  Dependencies will be installed automatically.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "The module is loaded as any other Julia module:  julia  using BinaryCommitteeMachineFBP  The code provides a main function,  focusingBP , and some auxiliary functions and types, documented below.  #  BinaryCommitteeMachineFBP.focusingBP     Function .  focusingBP(N, K, patternspec; keywords...)  Run the Focusing Belief Propagation algorithm on a fully-connected committee machine with binary weights.  N  is the input (first layer) size,  K  the number of the hidden units (second layer size), and  patternspec  specifies how to build the patterns for the training set. Note that with the defult settings  K  must be odd (see notes for the  accuracy1  and  accuracy2  arguments below).  Possible values of  patternspec  are:   a  Float64  number: this is interpreted as the  \u03b1  parameter, and  M = \u03b1*N*K  random \u00b11 patterns are generated.  a  Tuple  with  Vector{Vector{Float64}}  and a  Vector{Float64} : these are the inputs and associated desired outputs.  a string: the patterns are read from a file (one input pattern per line, entries separated by whitespace, outputs are           assumed to be all 1); the file can be gzipped.  a  Patterns  object (which could be the output of a previous run of the function).   Note : all inputs and outputs must be \u2208 {-1,1}.  The keyword arguments are:   max_iters  (default =  1000 ): maximum number of BP iterations per step. If convergence is not achieved in this many iterations,                                 the algorithm proceeds to the next step.  max_steps  (default =  typemax(Int) ): maximum number of focusing steps.  seed  (default =  1 ): random seed.  damping  (default =  0 ): BP damping parameter (between  0  and  1 ;  0  = no damping).  quiet  (default =  false ): whether to print on screen  accuracy1  (default =  :accurate ): accuracy of the messages computation at the hidden units level. Possible values are:                                       :accurate  (Gaussian approximation, good for large  N , works in  O(N)  time),                                       :exact  (no approximation, uses convolutions, good for small  N , works in  O(N\u00b3)  time, requires                                       N  to be odd),                                       :none  (a TAP-like approximation, fast but never very good, should probably be removed or done                                      properly...).  accuracy2  (default =  :exact ): accuracy of the messages computation at the output node level.                                   See  accuracy1  (and think of  K  instead of  N ).  randfact  (default =  0.01 ): random factor used in the initialization of the messages. Must be between  0  and  1 . Large values are                                not a good idea.  fprotocol  (default =  StandardReinforcement(1e-2) ): focusing protocol specification. See  FocusingProtocol .  \u03f5  (default =  1e-3 ): convergence criterion: BP is assumed to have converged when the difference between messages in two successive                         iterations is smaller than this value. Reduce it (e.g. to 1e-6) for more precise results, while increasing                          max_iters .  messfmt  (default =  :tanh ): internal storage format for messages: it can be either  :tanh  or  :plain ;  :tanh  is much more                                precise but slower.  initmess  (default =  nothing ): how to initialize the messages. If  nothing , they are initialized randomly; If a string is given,                                   they are read from a file (see also  read_messages  and  write_messages ). If a                                    Messages  object is given (e.g. one returned from an earlier run of the function, or from                                    read_messages ) it is used (and overwritten).  outatzero  (default =  true ): if  true , the algorithm exits as soon as a solution to the learning problem is found, without waiting                                 for the focusing protocol to terminate.  writeoutfile  (default =  :auto ): whether to write results on an output file. Can be  :never ,  :always  or  :auto . The latter means                                     that a file is written when  outatzero  is set to  false  and only when BP converges. It can make sense                                     setting this to  :always  even when  outfile  is  nothing  to force the computation of the local                                     entropy and other thermodynamic quantities.  outfile  (default =  nothing ): the output file name.  nothing  means no output file is written. An empty string means using a default                                  file name of the form:  \"results_BPCR_N$(N)_K$(K)_M$(M)_s$(seed).txt\" .  outmessfiletmpl  (default =  nothing ): template file name for writing the messages at each focusing step. The file name should include a                                          substring  \"%gamma%\"  which will be substituted with the value of the  \u03b3  parameter at each step.                                          If  nothing , it is not used. If empty, the default will be used:                                           \"messages_BPCR_N$(N)_K$(K)_M$(M)_g%gamma%_s$(seed).txt.gz\" .                                           Note : this can produce a lot of fairly large files!.   The function returns three objects: the number of training errors, the messages and the patterns. The last two can be used as inputs to successive runs of the algorithms, as the  initmessages  keyword argument and the  patternspec  argument, respectively.  Example of a run which solves a problem with  N * K = 1605  synapses with  K = 5  at  \u03b1 = 0.3 :  julia  errs, messages, patterns = B.focusingBP(321, 5, 0.3, randfact=0.1, seed=135, max_iters=1, damping=0.5);  source", 
            "title": "Usage"
        }, 
        {
            "location": "/#focusing-protocols", 
            "text": "#  BinaryCommitteeMachineFBP.FocusingProtocol     Type .  FocusingProtocol  Abstract type representing a protocol for the focusing procedure, i.e. a way to produce successive values for the quantities  \u03b3 ,  y  and  \u03b2 . Currently, however, only  \u03b2=Inf  is supported. To be provided as an argument to  focusingBP .  Available protocols are:  StandardReinforcement ,  Scoping ,  PseudoReinforcement  and  FreeScoping .  source  #  BinaryCommitteeMachineFBP.StandardReinforcement     Type .  StandardReinforcement(r::Range)  : FocusingProtocol  Standard reinforcement protocol, returns  \u03b3=Inf  and  y=1/(1-x) , where  x  is taken from the given range  r .  source  StandardReinforcement(dr::Float64)  : FocusingProtocol  Shorthand for  StandardReinforcement (0:dr:(1-dr)) .  source  #  BinaryCommitteeMachineFBP.Scoping     Type .  Scoping(\u03b3r::Range, y)  : FocusingProtocol  Focusing protocol with fixed  y  and a varying  \u03b3  taken from the given  \u03b3r  range.  source  #  BinaryCommitteeMachineFBP.PseudoReinforcement     Type .  PseudoReinforcement(r::Range...; x=0.5)  : FocusingProtocol  A focusing protocol in which both  \u03b3  and  y  are progressively increased, according to the formulas  \u03b3 = atanh(\u03c1^x)\ny = 1+\u03c1^(1-2x)/(1-\u03c1)  where  \u03c1  is taken from the given range(s)  r . With  x=0 , this is basically the same as  StandardReinforcement .  source  PseudoReinforcement(dr::Float64; x=0.5)  : FocusingProtocol  Shorthand for  PseudoReinforcement (0:dr:(1-dr); x=x) .  source  #  BinaryCommitteeMachineFBP.FreeScoping     Type .  FreeScoping(list::Vector{NTuple{2,Float64}})  : FocusingProtocol  A focusing protocol which just returns the values of  (\u03b3,y)  from the given  list .  Example:  FreeScoping([(1/(1-x), (2-x)/(1-x)) for x = 0:0.01:0.99])  source", 
            "title": "Focusing protocols"
        }, 
        {
            "location": "/#reading-and-writing-messages-files", 
            "text": "#  BinaryCommitteeMachineFBP.read_messages     Function .  read_messages(filename, mag_type)  Reads messages from a file.  mag_type  is the internal storage format used in the resulting  Messages  object, it can be either  MagT64  (uses tanhs, accurate but slower) or  MagP64  (plain format, faster but inaccurate).  The file format is the one produced by  write_messages .  source  #  BinaryCommitteeMachineFBP.write_messages     Function .  write_messages(filename, messages)  Writes messages to a file. The messages can be read back with  read_messages . Note that the output is a plain text file compressed with gzip.  source", 
            "title": "Reading and writing messages files"
        }
    ]
}